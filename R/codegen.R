#' Generate C function exports and R wrappers for decorated functions
#'
#' Functions decorated with `[[cpp11::export]]` in files ending in `.cc`,
#' `.cpp`, `.h` or `.hpp` will be wrapped in generated code which allows them to be
#' called from R.
#'
#' @param path The path to the package root directory
#' @return The paths to the generated R and C++ source files (in that order).
#' @export
cpp_generate_bindings <- function(path = ".") {
  `%>%` <- dplyr::`%>%`
  r_exports <- file.path(path, "R", "cpp11-bindings.cpp")
  cpp_bindings <- file.path(path, "src", "cpp11-bindings.cpp")
  unlink(c(r_exports, cpp_bindings))

  suppressWarnings(
    all_decorations <- decor::cpp_decorations(path, is_attribute = TRUE)
  )

  if (nrow(all_decorations) == 0) {
    return()
  }

  inits <- get_init_functions(all_decorations)

  exports <- get_exported_functions(all_decorations, "cpp11")

  package <- desc::desc_get("Package")

  cpp_functions_definitions <- generate_cpp_functions(exports, package)

  r_functions <- generate_r_functions(exports, package)

  writeLines(con = r_exports, glue::glue('
      # Generated by cpp11: do not edit by hand

      {r_functions}

      '
  ))
  cli::cli_alert_success("generated file {.file {basename(r_exports)}}")

  call_entries <- get_call_entries(path)

  cpp_functions_registration <- exports %>%
    dplyr::select(name, return_type, args) %>%
    purrr::pmap_chr(function(name, return_type, args){
      glue::glue('    {{ "_cpp11_{name}", (DL_FUNC) &_{package}_{name}, {nrow(args)}}}, ')
  }) %>%
    glue::glue_collapse(sep  = "\n")

  extra_includes <-  character()
  if (pkg_links_to_rcpp(path)) {
    extra_includes <- c(extra_includes, "#include <Rcpp.h>", "using namespace Rcpp;")
  }

  pkg_types <- file.path(path, "src", paste0(package, "_types.h"))
  if (file.exists(pkg_types)) {
    extra_includes <- c(sprintf('#include "%s"', basename(pkg_types)), extra_includes)
  }

  extra_includes <- paste0(extra_includes, collapse = "\n")

  writeLines(con = cpp_bindings, glue::glue('
      // Generated by cpp11: do not edit by hand

      #include "cpp11/declarations.hpp"
      {extra_includes}

      {cpp_functions_definitions}

      extern "C" {{
      {call_entries}
      }}

      {declarations}

      extern "C" void R_init_{package}(DllInfo* dll){{
        R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
        R_useDynamicSymbols(dll, FALSE);
        {calls}
      }}

      ',
      call_entries = glue::glue_collapse(call_entries, "\n"),
      declarations = glue::glue_collapse(inits$declarations, "\n"),
      calls = glue::glue_collapse(inits$calls, "\n  ")
  ))

  cli::cli_alert_success("generated file {.file {basename(cpp_bindings)}}")

  invisible(c(r_exports, cpp_bindings))
}

utils::globalVariables(c("name", "return_type", "line", "decoration", "context", ".", "functions"))

get_exported_functions <- function(decorations, export_tag) {
  `%>%` <- dplyr::`%>%`

  out <- decorations %>%
    dplyr::filter(decoration %in% paste0(export_tag, "::export")) %>%
    # the three lines below can be expressed with rap()
    # more concisely
    # rap(            ~ decor:::parse_cpp_function(context))
    dplyr::mutate(functions = purrr::map(context, asNamespace("decor")$parse_cpp_function)) %>%
    { vctrs::vec_cbind(., vctrs::vec_rbind(!!!dplyr::pull(., functions))) } %>%
    dplyr::select(-functions) %>%
    dplyr::mutate(
      decoration = sub("::export", "", decoration),
      return_type = sub("\\[\\[cpp11::[[:alpha:]]+\\]\\][[:space:]]*", "", return_type)
    )

  cli::cli_alert_info(glue::glue("{n} functions decorated with [[{tags}::export]]", n = nrow(out), tags = paste0(export_tag, collapse = "|")))

  out
}

generate_cpp_functions <- function(exports, package = "cpp11") {
  `%>%` <- dplyr::`%>%`

  exports %>%
    dplyr::select(name, return_type, args, file, line, decoration) %>%
    purrr::pmap_chr(function(name, return_type, args, file, line, decoration){
      glue::glue('
        // {basename(file)}
        {return_type} {name}({real_params});
        extern "C" SEXP _{package}_{name}({sexp_params}) {{
          BEGIN_CPP11
          {wrap_call(name, return_type, args)}
          END_CPP11
        }}
        ',
        sep = "\n",
        real_params = glue_collapse_data(args, "{type} {name}"),
        sexp_params = glue_collapse_data(args, "SEXP {name}")
        #input_params = glue_collapse_data(args, "  {type} {name}({name}_sexp);", sep = "\n"),
      )
    }) %>%
    glue::glue_collapse(sep = "\n")
}

generate_r_functions <- function(exports, package = "cpp11") {
  `%>%` <- dplyr::`%>%`

  exports %>%
    dplyr::select(name, return_type, args) %>%
    purrr::pmap_chr(function(name, return_type, args) {
      params <- if (nrow(args)) {
        paste0(", ", glue_collapse_data(args, "{name}"))
      } else {
        ""
      }
      call <- if(return_type == "void") {
        glue::glue('invisible(.Call("_{package}_{name}", PACKAGE = "{package}" {params}))')
      } else {
        glue::glue('.Call("_{package}_{name}" {params})')
      }

      glue::glue('
        {name} <- function({list_params}){{
          {call}
        }}

        ',
        list_params = glue_collapse_data(args, "{name}"),
        sep = "\n"
        ) }) %>%
    glue::glue_collapse(sep = "\n")
}

glue_collapse_data <- function(data, ..., sep = ", ", last = "") {
  res <- glue::glue_collapse(glue::glue_data(data, ...), sep = sep, last = last)
  if(length(res) == 0) res <- ""
  res
}

wrap_call <- function(name, return_type, args) {
  call <- glue::glue('{name}({list_params})', list_params = glue_collapse_data(args, "cpp11::unmove(cpp11::as_cpp<{type}>({name}))"))
  if(return_type == "void") {
    glue::glue("  {call};\n  return R_NilValue;", .trim = FALSE)
  } else {
    glue::glue("  return cpp11::as_sexp({call});")
  }
}

get_init_functions <- function(decorations) {
  `%>%` <- dplyr::`%>%`
  inits <- decorations %>% dplyr::filter(decoration == "cpp11::init")

  if (nrow(inits) == 0) {
    return(list(declarations = "", calls = ""))
  }

  inits <- inits %>%
    dplyr::mutate(functions = purrr::map(context, asNamespace("decor")$parse_cpp_function)) %>%
    { vctrs::vec_cbind(., vctrs::vec_rbind(!!!dplyr::pull(., functions))) } %>%
    dplyr::select(-functions) %>%
    dplyr::mutate(return_type = sub("\\[\\[cpp11::[[:alpha:]]+\\]\\][[:space:]]*", "", return_type))

  declarations <- glue::glue_data(inits, "{return_type} {name}({param_type} {param_name});", param_type = purrr::map_chr(args, "type"), param_name = purrr::map_chr(args, "name"))
  calls <- glue::glue_data(inits, "{name}({params});", params = purrr::map_chr(args, "name"))

  cli::cli_alert_info(glue::glue("{n} functions decorated with [[cpp11::init]]", n = nrow(inits)))

  list(
    declarations = declarations,
    calls = calls
  )
}

get_call_entries <- function(path) {
  res <- utils::capture.output(tools::package_native_routine_registration_skeleton(path, character_only = FALSE))
  start <- grep("/* .Call calls */", res, fixed = TRUE)
  end <- grep("};", res, fixed = TRUE)
  res[seq(start, end)]
}

pkg_links_to_rcpp <- function(path) {
  deps <- desc::desc_get_deps(file.path(path, "DESCRIPTION"))

  any(deps$type == "LinkingTo" & deps$package == "Rcpp")
}
